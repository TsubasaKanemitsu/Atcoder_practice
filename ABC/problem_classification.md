# Atcoder問題傾向対策


## 入出力観点

## 文字列操作観点
### 44B
- 解答時間 
    - 7分
- パターン 
    - 文字列カウント
- 考察
文字列中に存在する英子文字が偶数個ずつ存在するか確認すればいいので，
set()で一意な英子文字を抽出し，それらの英子文字が偶数個であるかを文字列に対してcountで求めその値を÷2し，その時の余りが0 or 1で偶数か奇数化を判定すればいい．

## 演算観点
### 121C
- 解答時間
    - 解けなかった(復習はいらない，問題を解く方針は合っていた)
- パターン
    - 数え上げ
- 考察
最少の金額で栄養ドリンクを必要数購入する問題なので，
値段がもっと安い店舗で順に必要数に到達するまでドリンクを買い続ければいい
- ミスの要因
本数と値段の関係をdefaultdictで状態管理を行っていたが，なぜか値段を安くする順番にするソートが上手くいっていなかったため，計算結果が誤るテストパターンがあった．
defaultdictではなく，リストに変更するとACできた．
```
n, m = list(map(int, input().split()))
data = []
for i in range(n):
    a, b = list(map(int, input().split()))
    data.append((a, b))

data.sort()

money = 0
for i in data:
    if m >= i[1]:
        m -= i[1]
        money += i[0] * i[1]
    else:
        money += m * i[0]
        break
print(money)
```
### 124C
- 解答時間
    - 解けた(10分)
- パターン
    - 数え上げ
- 考察
この問題では元の文字列のどの部分を変更することで隣同士の色を異なるようにすることができるかを調べたい．最少の変更回数を求めたい．
隣同士が異なる色のパターンは白黒白か黒白黒の2パターンなのでこの2パターンのうちどちらのパターンが元の文字列のパターンと近いかを調べれば最少回数で隣同士の色を異なるようにすることができると言える．
```
s = input()

odd = ''
even = ''
odd_count = 0
even_count = 0
for i in range(len(s)):
    if i % 2 == 0:
        odd = '0'
        even = '1'
    else:
        odd = '1'
        even = '0'

    if odd != s[i]:
        odd_count += 1
    elif even != s[i]:
        even_count += 1

print(min(odd_count, even_count))
```
### 127C
- 解答時間
    - 解けた(19分)
- パターン
    - 数え上げ
- 考察
ゲートを全て通ることのできる整数の数を求めることを考えればいい．
全てのゲートを介していくうちに下限と上限が徐々に狭まっていくので，狭まっていく下限と上限を更新しつづけ,最終的な下限の状態と上限の状態を管理し，
最後にその範囲の整数の数をカウントすればいい．
```
n, m = list(map(int, input().split()))

L, R = [], []

for i in range(m):
    l, r = list(map(int, input().split()))
    L.append(l)
    R.append(r)

low = L[0]
high = R[0]

for i in range(1, m):
    if low < L[i]:
        low = L[i]
    else:
        pass
    if high > R[i]:
        high = R[i]
    else:
        pass
   
num = [i for i in range(low, high + 1)]
print(len(num))
```
### 132C
- 解答時間
    - 解けた(12分)
- パターン
    - 数え上げ
- 考察
ABCとARCの問題に分類される数が同じになるということは，問題の難易度が順番に並べられたときに半分の位置にくる数値がABCとARCの境界に関わる数値となる．よって半分に分割できる数値のパターンは半分の位置の数値とその1つ手前数値の間でとれる整数全てということになる．
```
k = int(input())

D = list(map(int, input().split()))
D.sort()
mid_num = D[k // 2]
mid_prev_num = D[k // 2 - 1]
num = [i for i in range(mid_prev_num + 1, mid_num + 1)]
print(len(num))
```
### 135C
- 解答時間
    - 解けた(19分)
- パターン
    - 数え上げ
- 考察
勇者は，i, i + 1番目の町を襲っているモンスターを倒すことができるので，BiがAiより大きい場合，その差分の分だけ次の町のモンスターを倒すことができる．よって，合計値はA[i] + diff(B[i] - A[i])ずつ足していくことで倒したモンスターの数をカウントできる．注意すべき点は，勇者(Bi)がi番目の町にいるモンスターより多くモンスターを倒すことができる場合，A[i + 1]の値を更新することができる．そのときにBiのモンスターを倒せる数がB[i] > A[i] + A[i + 1]の状況でdiff(B[i] - A[i])分をA[i + 1]から減らすとA[i + 1]のモンスターの数がマイナスになってしまうので，diffは最大でもA[i + 1]までにしかならないようにする必要がある．
```
n = int(input())

A = list(map(int, input().split()))
B = list(map(int, input().split()))

sum_val = 0
for i in range(n):

    if A[i] >= B[i]:
        sum_val += B[i]
    elif B[i] > A[i]:
        diff = B[i] - A[i]
        
        if diff > A[i + 1]:
            diff = A[i + 1]
        sum_val += A[i] + diff
        A[i + 1] = A[i + 1] - diff
    
print(sum_val)
```
### 139D
- 解答時間
    - 解けた(10分)
- パターン
    - 余りの累積和
- 考察
この問題で条件が与えられた各項の余りが最大となるのは，各項より1つ大きい値でそれぞれの項が割られると商が0, 余りが項のままとなり余りが最大値をとることになる．
結果的に最も値の大きい項は自分より1大きい値がないので必然的に割る数は1となり，余りは0となる．そのため，余りの総和の最大値は (1 mod 2) + (2 mod 3) + ... (n - 1 mod n) + (n mod 1)となる．ここでNは10の9乗のため，全ての項に対して演算を行うと計算時間が間に合わない(O(N)かかる)ため，累積和の公式を使う. n(n + 1)/2で1 + ... + Nまでの総和が表せることを利用することでO(1)で計算結果を出せることができる
```
n = int(input())

ans = n * (n - 1) // 2
print(ans)
```
## 制御フロー観点
### 86C.py
- 解答時間
    - 解けた(25分)
    - WA 2回
    - テストケースが1つだけ通らなくて, 時間を浪費した
- パターン
    - 座標移動
- 考察
制約として時刻t -> t + 1毎に必ずx座標かy座標をを +1 or -1 する必要がある．そのためその場にとどまることが許されない状態で移動可能かどうかを判定する方法として移動不可能なパターンとして以下の2点を考えた．1点目は，時刻tから次の時刻の移動可能距離(diff_t)がx, y座標それぞれの次の座標までの移動距離の総和(diff = diff_x + diff_y)より小さいときは移動が不可能であると考える．2点目は，移動可能距離から移動距離を引いた値(diff_t - diff)が偶数でないときは，移動不可能と判定する．これはなぜかというと移動可能距離が移動距離より大きいということは制限時間内に移動すべき位置へ行く時間は足りているので，あとはその場にとどまるための移動を行えばいい．移動時間が偶数の場合は，進んで戻るという行為が行えるが奇数の場合は進んだものの戻ることができないためとどまる行動ができたいという風に考えることができる．
```
n = int(input())

result = "Yes"
temp_x = 0
temp_y = 0
temp_t = 0
for i in range(n):
    t, x, y = list(map(int, input().split()))
    diff_x = abs(x - temp_x)
    diff_y = abs(y - temp_y)
    diff_t = t - temp_t
    diff = diff_x + diff_y

    if diff_t >= diff and (diff_t - diff) % 2 == 0:
        pass
    else:
        result = "No"
    temp_x = x
    temp_y = y
    temp_t = t

print(result)
```
### 87C
- 解答時間
    - 解答できた(25分)
    - 足し合わせ方法を具体的に書かなかったのが，遅かった原因
- パターン
    - 足し算
    - 全探索
- 考察
この問題は右か下にしか移動できないので一度2段目に下りると上がることはできなくなる．
そのため，キャンディーを拾える方法はある地点まで右に移動したときに拾ったキャンディの数と，2段目に下りてから右に移動したときに拾ったキャンディの数をあるルートで移動した場合に拾えるキャンディの総和と考える．そう考えると1ずつ右に移動して，そこから下に下りて右に移動するというルートの全探索を行い，最大で拾えるキャンディの数を更新し続ければいい．
```
n = int(input())

A_1 = list(map(int, input().split()))
A_2 = list(map(int, input().split()))

ans = 0
for i in range(n):
    temp_ans = sum(A_1[0:i + 1]) + sum(A_2[i:])
    ans = max(ans, temp_ans)
print(ans)
```

### 120C(復習)
- 解答時間
    - 解答できなかった
- パターン
    - 文字列検索
- 原因
0と1が隣あっているかどうかを配列同士の比較を行い判定していたため，
計算時間がかかりすぎていた．
- 考察
単純に考えれば，0と1が隣あったときにブロックを消すので，0と1の最小の数に合わせた分だけブロックを消すことができる最大の回数であるとわかる．
### 136C
- 解答時間
    - 解けた(10分)
- 考察
単調増加するビルの条件として右隣のビルの高さが自分と同じか自分より低いまたは1だけ低くする操作をした場合に同じ高さにすることができるという条件が
全ての位置のビルにおいて成り立つかどうかを検証すればいい．
また，別の解答として対象のビルに対して右隣のビルが2以上高い場合はNoという方法も考えられる．
(単調減少し続けているかを判断する)
- 解答
```
n = int(input())

H = list(map(int, input().split()))
H.reverse()
for i in range(n - 1):
    if H[i] >= H[i + 1]:
        continue
    else:
        H[i + 1] = H[i + 1] - 1
        if H[i] >= H[i + 1]:
            continue
        else:
            print("No")
            exit(0)
print("Yes")
```
## 組み込み関数観点

## モジュール観点
### 79C
- 解答時間
    - 解けた(20分)
- 全探索
    - itertoolsを使えばすぐできる
- 考察
4つの数字を+, -の演算を用いて7になる場合の数式と答えを出力すればいいので，
全パターンの計算を試し，答えが7になるときの数式と答えを出力すればいい
- 感想
文字列の足し算などで凡ミスをしてしまい解答に時間がかかってしまった
解き方の方針自体はすぐに出た．
```
import itertools
num = list(map(int, input()))

for perm in itertools.product(['+', '-'], repeat=3):
    flag = False
    ans = num[0]
    str_ans = str(num[0])
    for index, p in enumerate(perm):
        if p == '+':
            ans += num[index + 1]
            str_ans += p + str(num[index + 1])
        else:
            ans -= num[index + 1]
            str_ans += p + str(num[index + 1])
    if ans == 7:
        print(f'{str_ans}={ans}')
        flag = True
        break
    if flag:
        break
```
## データ構造観点

## アルゴリズム観点
### 144C
- 解答時間
    - 解けた(10分)
- パターン
    - 約数列挙の応用
- 考察
(1, 1)から(a, b)に至るまでの移動回数はa + b -2となる．
a, bを求めるとき，全探索をしていては計算時間内に処理を終わらせることができないので計算量を減らす方法を考える必要がある．
そこで，a, bはNを割ったときの数と商の組み合わせで求め，更にa≤bの対称性を用いることで計算量をO(N)からO(√N)に減らすように実装する．
```
n = int(input())

def get_max_div_mod(n):
    itr = 1
    result = [1, 1]
    while itr * itr <= n:
        if n % itr == 0:
            result = [itr, n // itr]
        itr += 1
       
    return result

result = get_max_div_mod(n)

print(sum(result) - 2)  
```
## 計算量観点
### 100(復習)
- 解答時間
    - 解けなかった
- パターン
    - 剰余の特性に関する問題
- 考察
× 3 を N - 1回 ÷　2を1回をN個の数列に対して行う．
この操作が行えなくなったら終了という風に考えていた．
計算量的にこの方針ではダメだった．
× 3をしても初期値として与えられる数値の÷2を行える回数は変化しない.
そのため，計算処理が必要なのは，数列の各項が÷2を何回行えるのかを求めればいい．
```
n = int(input())

A = list(map(int, input().split()))
count = 0
for i in range(len(A)):
    while A[i] % 2 == 0:
        if A[i] % 2 == 0:
            A[i] /= 2
            count += 1

print(count)

```
### 115C
- 解答時間
    - 解答できた(25分)
- パターン
    - 計算量観点
    - ソート & 大小比較
- 考察
考察1. 
最初に思いついたのは，全探索で行う方法．n, kの組み合わせで全探索を行い，各組み合わせの最小と最大の差が最も小さい値を出力するようにしていた．
しかし，これでは計算量的に問題があるのでWAを出してしまう．
考察2
選ばれた木の高さ同士の高さが近いかつの最大と最小の差が小さい値を出力できればいいので，木の高さ順にソートを行い，i番目とi+(k-1)番目の木を比較することで木の高さ同士が近い状況かつ選ばれた木の高さの最大と最小の差を小さくすることが可能になる．
この方法ならO(N)で処理を完了させることができる．
```
n, k = list(map(int, input().split()))

h = [int(input()) for _ in range(n)]
h.sort(reverse=True)
diff = 10 ** 9
for i in range(n - k + 1):
    temp_diff = h[i] - h[i + k - 1]
    diff = min(diff, temp_diff)

print(diff)
```
### 134C
- 解答時間
    - 解けなかった
- パターン
    - 最大値を求める問題
- 考察
自分以外の要素の中での最大値を求める．
自分より左側と右側の最大値を管理し，自分の左右の最大値同士を比較していく．
自分との比較対象が常に左側，右側の最大値になるように管理することで毎回自分以外の要素から最大値を探索する必要がなくなるため，計算量を削減することができる
```
n = int(input())
A = []
for i in range(n):
    A.append(int(input()))

# 最初に0を入れないと1回目の
# 自分より左の最大値の管理
left = [0]
# 自分より右の最大値の管理
right = [0]

for a in A:
    left.append(max(a, left[-1]))

for a in reversed(A):
    right.append(max(a, right[-1]))

for i in range(n):
    print(max(left[i], right[n - i - 1]))
```

## 数学観点
### 55B
- 解答時間
    - 解けた(4分)
- パターン
    - mod p における割り算(合同式の性質)
- 考察
今回の問題はN!を10 ** 9 + 7で割ったときの余りを求める問題である．
しかし，単純にN!を計算し，10 ** 9 + 7で割ると数値が大きくなっている場合，
オーバーフローが発生する．そのため合同式の積の性質を用いて問題を解けばいい.
例： 10 ≡ 3 mod 7は10 % 7と3 % 7の余りの値が同じという性質を表している．
これに合同式の積の性質を用いて考えると, 30 ≡ 9 mod 7はどちらも余りが２となり，
余りが一致していることがわかる．よって求める値は, ans * i ≡ (ans * i mod 10 ** 9 + 7) mod (10 ** 9 + 7)ということになる. これによりN!倍していく過程において常に小さい値で演算を行えるので，オーバーフローが発生しない．
```
n = int(input())

ans = 1
for i in range(1, n + 1):
    ans = ans * i % (10 ** 9 + 7)
print(ans % (10 ** 9 + 7))

```
## 93C(復習)
- 解答時間
    - 解答できなかった
- パターン
    - 数の偶奇の性質の考察
- 感想
    - 実装の取っ掛かりすら，思いつけてなかった．制約条件が行われた時の数の性質について考察を深める必要がある．
- 考察
今回の2種類の操作ではどちらも総和として+2になるので操作前と操作後で総和の偶奇は変化しない．
そのため，総和の偶奇が一致している場合は操作後の総和であるmax(a, b, c) × 3から操作前の(a + b + c) の差を÷2した数が操作回数となる．(1操作で総和は2変化するので2で割っている．)一方，総和の偶奇が一致しない場合は， a, b, cを合わせるための基準となる最大値max(a, b, c)を+1して(下げる操作はないため)，偶奇が一致するように最大値を再設定する必要がある．そのため偶奇が一致しないときは(max(a ,b, c) + 1) × 3から(a + b + c)の差を÷2した数が操作回数となる.
```
A, B, C = map(int, input().split())

M = max(A, B, C)

if 3 * M % 2 == (A + B + C) % 2:
    print((3 * M - (A + B + C)) // 2)

else:
    print((3 * (M + 1) - (A + B + C)) // 2)
```
## 140C
- 解答時間
    - 解けなかった
- パターン
    - 数列の問題(最大値を取り続ける)
- 考察
数列関係の問題は見ただけですぐに理解しにくいので，実際の値を書き出してみて，
パターンがありそうか観察してみること．(具体化 -> 一般化)
- 考察: [解説記事](https://drken1215.hatenablog.com/entry/2019/09/16/201500)
- 数列の前後の関係性に注目する()


## カテゴリ観点