# ABC 212
# 42分

# 優先度キュー & 累積和
# 4WA

# 考察
# STEP1
# 最小の値を取り出し方：リストのソートではTLEになるので、優先度キューによる取り出しを考える
# STEP2
# 操作2で値を愚直に加算するのは、O(N)かかってしまうので、加算する値をO(1)で
# 実行することはできないかを考える
# 加算する値は、累積和として値を記録しておき、値が追加されたタイミングと値が吐き出されるタイミングの
# 差をとることで値を吐き出すタイミングにおける加算量を求めることができる。
# STEP3
# 優先度キューによるソートを行うときに、中の値は実際は加算されていないため、
# ただ単に値を追加するだけでは、優先度キューの中身は加算された値が反映されていない状態で
# 並び替えを行うことになり、加算を考慮した上での最小値を求めることができない
# そこで値を追加するとき、キューの中身はこれまでの累積和分が加算されているということは
# 新たに追加する値は、相対的に見ると累積和分小さいと考えることができるので、
# 追加する値から現在の累積和分の値を引いて、優先度キューに値を追加することで
# 加算を考慮した上での並び替えが可能になる。

import heapq
q = int(input())

heap = []
heapq.heapify(heap)

add = [0] * (2 * 10 ** 5)
add_cnt = 0
ans = []
for i in range(q):
    query = list(map(int, input().split()))
    if query[0] == 1:
        heapq.heappush(heap, (query[1] - add[add_cnt], add_cnt))
    elif query[0] == 2:
        add_cnt += 1
        add[add_cnt] = add[add_cnt - 1] + query[1]
    else:
        p, cnt = heapq.heappop(heap)
        p += add[add_cnt] #- add[cnt]
        ans += [p]
for a in ans:
    print(a)