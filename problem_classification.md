# Atcoder問題傾向対策


## 入出力観点
## 演算観点
- 132C
    - 解けた(12分)
    - パターン:数え上げ
- 考察
ABCとARCの問題に分類される数が同じになるということは，問題の難易度が順番に並べられたときに半分の位置にくる数値がABCとARCの境界に関わる数値となる．よって半分に分割できる数値のパターンは半分の位置の数値とその1つ手前数値の間でとれる整数全てということになる．
```
k = int(input())

D = list(map(int, input().split()))
D.sort()
mid_num = D[k // 2]
mid_prev_num = D[k // 2 - 1]
num = [i for i in range(mid_prev_num + 1, mid_num + 1)]
print(len(num))
```
- 124C
    - 解けた(10分)
    - パターン:数え上げ
- 考察
この問題では元の文字列のどの部分を変更することで隣同士の色を異なるようにすることができるかを調べたい．最少の変更回数を求めたい．
隣同士が異なる色のパターンは白黒白か黒白黒の2パターンなのでこの2パターンのうちどちらのパターンが元の文字列のパターンと近いかを調べれば最少回数で隣同士の色を異なるようにすることができると言える．
- 127C
    - 解けた(19分)
    - パターン:数え上げ
- 考察
ゲートを全て通ることのできる整数の数を求めることを考えればいい．
全てのゲートを介していくうちに下限と上限が徐々に狭まっていくので，狭まっていく下限と上限を更新しつづけ,最終的な下限の状態と上限の状態を管理し，
最後にその範囲の整数の数をカウントすればいい．
```
n, m = list(map(int, input().split()))

L, R = [], []

for i in range(m):
    l, r = list(map(int, input().split()))
    L.append(l)
    R.append(r)

low = L[0]
high = R[0]

for i in range(1, m):
    if low < L[i]:
        low = L[i]
    else:
        pass
    if high > R[i]:
        high = R[i]
    else:
        pass
   
num = [i for i in range(low, high + 1)]
print(len(num))
```
- 135C
    - 解けた(19分)
    - パターン:数え上げ
- 考察
勇者は，i, i + 1番目の町を襲っているモンスターを倒すことができるので，BiがAiより大きい場合，その差分の分だけ次の町のモンスターを倒すことができる．よって，合計値はA[i] + diff(B[i] - A[i])ずつ足していくことで倒したモンスターの数をカウントできる．注意すべき点は，勇者(Bi)がi番目の町にいるモンスターより多くモンスターを倒すことができる場合，A[i + 1]の値を更新することができる．そのときにBiのモンスターを倒せる数がB[i] > A[i] + A[i + 1]の状況でdiff(B[i] - A[i])分をA[i + 1]から減らすとA[i + 1]のモンスターの数がマイナスになってしまうので，diffは最大でもA[i + 1]までにしかならないようにする必要がある．
## 制御フロー観点
- 136C
    - 解けた(10分)
- 考察
単調増加するビルの条件として右隣のビルの高さが自分と同じか自分より低いまたは1だけ低くする操作をした場合に同じ高さにすることができるという条件が
全ての位置のビルにおいて成り立つかどうかを検証すればいい．
また，別の解答として対象のビルに対して右隣のビルが2以上高い場合はNoという方法も考えられる．
(単調減少し続けているかを判断する)
- 解答
```
n = int(input())

H = list(map(int, input().split()))
H.reverse()
for i in range(n - 1):
    if H[i] >= H[i + 1]:
        continue
    else:
        H[i + 1] = H[i + 1] - 1
        if H[i] >= H[i + 1]:
            continue
        else:
            print("No")
            exit(0)
print("Yes")
```
## 組み込み関数観点

## モジュール観点

## データ構造観点

## アルゴリズム観点

## 計算量観点
- 134C問題
    - 解けなかった
- 最大値を求める問題
- 考察
自分以外の要素の中での最大値を求める．
自分より左側と右側の最大値を管理し，自分の左右の最大値同士を比較していく．
自分との比較対象が常に左側，右側の最大値になるように管理することで毎回自分以外の要素から最大値を探索する必要がなくなるため，計算量を削減することができる
```
n = int(input())
A = []
for i in range(n):
    A.append(int(input()))

# 最初に0を入れないと1回目の
# 自分より左の最大値の管理
left = [0]
# 自分より右の最大値の管理
right = [0]

for a in A:
    left.append(max(a, left[-1]))

for a in reversed(A):
    right.append(max(a, right[-1]))

for i in range(n):
    print(max(left[i], right[n - i - 1]))
```

## 数学観点
- 140C
    - 解けなかった
- 数列の問題(最大値を取り続ける)
- 考えること
数列関係の問題は見ただけですぐに理解しにくいので，実際の値を書き出してみて，
パターンがありそうか観察してみること．(具体化 -> 一般化)
- 考察: [解説記事](https://drken1215.hatenablog.com/entry/2019/09/16/201500)
- 数列の前後の関係性に注目する()


## カテゴリ観点